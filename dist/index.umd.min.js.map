{"version":3,"file":"index.umd.min.js","sources":["../src/utils.ts","../src/constants.ts","../src/logger.ts"],"sourcesContent":["import type { Style, Styles } from './types';\n\n/**\n * Creates instance of simple formatter.\n */\nexport function formatter(styles: Styles) {\n\n  const _tokens = [] as string[];\n  const _styles = [] as string[];\n\n  const api = {\n    tokens: _tokens,\n    styles: _styles,\n    add,\n    unstyled,\n    toString\n  };\n\n  /**\n   * Adds a styled value to tokens to be formatted.\n   * \n   * @param style the style to be applied.\n   * @param label the value to apply style to.\n   */\n  function add(style: Style, label: any) {\n    _tokens.push(`%c` + label)\n    _styles.push(styles[style]);\n    return api;\n  }\n\n  /**\n   * Add unstyled value.\n   * \n   * @param label the value to be unstyled.\n   */\n  function unstyled(label: any) {\n    return add('inherit', label);\n  }\n\n  /**\n   * Converts tokens and values to styled result for logging.\n   */\n  function toString() {\n    return [_tokens.join(' '), ..._styles];\n  }\n\n  return api;\n\n}\n\n/**\n * Gets a timestamp.\n * \n * @param date optional date.\n */\nexport function getTimestamp(date = Date.now()) {\n  return (new Date(date)).toISOString();\n}\n\n/**\n * Normalizes a namespace.\n * \n * @param ns the namespace to format.\n * @param parent the parent to be prefixed.\n */\nexport function formatNamespace(ns: string, parent: string) {\n  const segments = [...parent.split('.'), ns];\n  return segments.join('.');\n}\n\n/**\n * Converts an error to object literal.\n * \n * @param err the error to convert to object\n */\nexport function serializeError<E extends Error>(err: E & { [key: string]: any }) {\n  if (!(err instanceof Error))\n    return err;\n  const result = Object.getOwnPropertyNames(err).reduce((a, c) => {\n    a[c as keyof E] = err[c];\n    return a;\n  }, {} as Record<keyof E, any>);\n  if (err.name && !result.name)\n    result.name = err.name;\n  return result;\n}\n","import type { IStorageLoggerOptions, LogLevel } from './types';\n\nexport const ENV_LOG_LEVEL = typeof process !== 'undefined' ? process.env['REACT_APP_LOG_LEVEL'] : 'error';\n\nexport const LOG_LEVELS = <const>['log', 'fatal', 'error', 'warn', 'info', 'debug'];\n\nexport const STYLES = {\n  inherit: 'color: inherit',\n  dim: 'color: #666',\n  log: 'color: lightslategray',\n  fatal: 'color: gold; background-color: firebrick',\n  error: 'color: firebrick',\n  warn: 'color: gold',\n  info: 'color: deepskyblue',\n  debug: 'color: magenta'\n};\n\nexport const DEFAULTS = {\n  type: 'local' as 'local',\n  maxLines: 10,\n  key: '$uid' as IStorageLoggerOptions['key'],\n  keyValue: () => Date.now(),\n  userKey: 'user',\n  level: ENV_LOG_LEVEL as LogLevel,\n  consoleOutput: 'development' as IStorageLoggerOptions['consoleOutput'],\n  styles: { ...STYLES }\n};\n\n","import { formatNamespace, formatter, getTimestamp, serializeError } from './utils';\nimport { DEFAULTS, LOG_LEVELS } from './constants';\nimport type { IStorageLoggerOptions, LogLevel, \n  StorageLoggerEvent, StorageLoggerPayload, Style } from './types';\n\n/**\n * Creates a new storage logger instance.\n * \n * @param options storage logger options. \n * @param namespaces currently loaded namespaces.\n */\nfunction createStorageLogger<K extends string = '$uid', U extends Record<string, any> = Record<string, any>>(options: IStorageLoggerOptions<K>, namespaces: string[] = []) {\n\n  type Logger = typeof logger;\n\n  options = {\n    ...DEFAULTS as any,\n    ...options\n  };\n\n  const store = options.type === 'local' ? localStorage : sessionStorage;\n\n  const { parent, namespace, maxLines, key, keyValue, userKey, level: initLevel, consoleOutput, styles } = options as Required<IStorageLoggerOptions<K>>;\n\n  const activeNamespace = formatNamespace(namespace, parent);\n\n  let _queue: StorageLoggerEvent<K, U>[] = [];\n  let _queueId: any;\n\n  if (!namespaces.includes(activeNamespace))\n    namespaces.push(activeNamespace);\n\n  /**\n   * Clears the log queue.\n   */\n  function clearQueue() {\n    if (!_queueId) return;\n    clearInterval(_queueId);\n    _queue = [];\n  }\n\n  /**\n   * Starts the log queue.\n   */\n  function startQueue() {\n    _queueId = setInterval(() => {\n      if (!_queue.length)\n        return clearQueue();\n      writePayload(activeNamespace, _queue.shift() as StorageLoggerEvent<K, U>);\n    }, 150);\n  }\n\n  /**\n   * Gets namespaced value by key.\n   * \n   * @param ns the namespace to get.\n   */\n  function getKey(ns: string): StorageLoggerEvent<K, U>[] {\n    const obj = store.getItem(ns);\n    return obj && obj.length ? JSON.parse(obj) : [];\n  }\n\n  /**\n   * Gets a user from storage.\n   * NOTE: always uses localStorage.\n   * \n   * @param key the user key for retrieving user object.\n   */\n  function getUser(key: string) {\n    const user = localStorage.getItem(key);\n    const item = store.getItem(key);\n    if (!user || !item)\n      return null;\n    return JSON.parse(item);\n  }\n\n  /**\n   * Sets a namespace's value.\n   * \n   * @param ns the names apce to be set.\n   * @param data the value to set to the namespace.\n   */\n  function setKey(ns: string, data: StorageLoggerEvent<K, U> | StorageLoggerEvent<K, U>[]) {\n    if (!data) return;\n    if (!Array.isArray(data))\n      data = [data];\n    const str = JSON.stringify(data);\n    store.setItem(ns, str);\n  }\n\n  function removeKey(ns: string) {\n    store.removeItem(ns);\n  }\n\n  /**\n   * Deletes rows for the given namespace.\n   * \n   * @param ns the namespace to delete rows for.\n   * @param count the number of rows to delete if not 1.\n   */\n  function deleteRows(ns: string, count = 1) {\n    const rows = getKey(ns);\n    rows.sort((a, b) => {\n      if (a.timestamp > b.timestamp)\n        return 1;\n      else if (a.timestamp < b.timestamp)\n        return -1;\n      else\n        return 0;\n    }).splice(0, count);\n    setKey(ns, rows);\n  }\n\n  /**\n   * Gets the number of rows for a namespace.\n   * \n   * @param ns the namespace to get row count for.\n   */\n  function rowsCount(ns: string) {\n    return getKey(ns).length;\n  }\n\n  /**\n   * Gets the size of a namespace.\n   * \n   * @param ns the namespace to get size for.\n   */\n  function checkSize(ns: string) {\n    if (!maxLines) return;\n    const count = rowsCount(ns);\n    if (count === maxLines) {\n      deleteRows(ns);\n    }\n    else if (count > maxLines) {\n      const adj = count - maxLines;\n      deleteRows(ns, adj);\n    }\n  }\n\n  /**\n   * Checks if a level is active.\n   * \n   * @param level the level to inspect as active.\n   */\n  function isActiveLevel(level: LogLevel) {\n    const curIndex = LOG_LEVELS.indexOf(level);\n    const loggerIndex = LOG_LEVELS.indexOf(logger.level as LogLevel);\n    return curIndex <= loggerIndex;\n  }\n\n  /**\n   * Checks if should output to console as well as log to storage.\n   */\n  function shouldOutput() {\n    return (consoleOutput === 'always' || process.env['NODE_ENV'] !== 'production');\n  }\n\n  /**\n   * Writes the payload to storage by namespace.\n   * \n   * @param ns the namespace to be written.\n   * @param payload the payload to be written.\n   */\n  function writePayload(ns: string, payload: StorageLoggerEvent<K, U>) {\n    const rows = [...getKey(ns), payload];\n    if (shouldOutput()) {\n      const tsKey = getTimestamp(payload[key]).split('.').shift()?.split('T').join(' ');\n      const trimNs = ns.replace(/^logger\\./, '');\n      const truncMessage = payload.message.slice(0, 25);\n      const groupLabel = formatter(styles)\n        .add(payload.level as Style, tsKey)\n        .unstyled(trimNs)\n        .unstyled('-')\n        .add('dim', truncMessage)\n        .toString();\n      console.groupCollapsed(...groupLabel);\n      console.log(payload);\n      console.groupEnd();\n    }\n    setKey(ns, rows);\n  }\n\n  /**\n    * Logs a payload by log level.\n    * \n    * @param level the level being logged.\n    * @param payload the value or payload to log.\n    */\n  function logger(level: LogLevel, payload: StorageLoggerPayload): Logger;\n\n  /**\n   * Logs a payload by default level.\n   * \n   * @param payload the value or payload to log.\n   */\n  function logger(payload: StorageLoggerPayload): Logger;\n\n  function logger(level: LogLevel | StorageLoggerPayload, payload?: StorageLoggerPayload) {\n\n    // We don't want to log empty lines in local storage.\n    if (typeof level === 'undefined')\n      return logger;\n\n    if (!payload) {\n      payload = level;\n      level = '';\n    }\n\n    level = level || 'log';\n\n    if (!isActiveLevel(logger.level as LogLevel))\n      return logger;\n\n    if (typeof payload === 'string')\n      payload = { message: payload };\n\n    else if (payload instanceof Error)\n      payload = serializeError(payload);\n\n    checkSize(activeNamespace);\n\n    const _payload = payload as StorageLoggerEvent<K, U>;\n    _payload[key as K] = keyValue() as any;\n    _payload.namespace = activeNamespace;\n    _payload.timestamp = getTimestamp();\n    _payload.message = _payload.message || '';\n\n    if (userKey)\n      _payload.user = getUser(userKey);\n\n    // Add to the queue.\n    _queue.push(_payload);\n\n    if (!_queueId)\n      startQueue();\n\n    return logger;\n\n  }\n\n  /**\n   * The current enabled log level.\n   */\n  logger.level = initLevel as Omit<LogLevel, 'log'>;\n\n  /**\n   * The active namespace.\n   */\n  logger.namespace = activeNamespace;\n\n  /**\n   * An array of logger namespaces.\n   */\n  logger.namespaces = namespaces;\n\n  /**\n   * Logs a payload by default level.\n   * \n   * @param payload the payload to be logged.\n   */\n  logger.log = (payload: StorageLoggerPayload) => logger('log', payload);\n\n  /**\n   * Logs a payload by fatal log level.\n   * \n   * @param payload the payload to be logged.\n   */\n  logger.fatal = (payload: StorageLoggerPayload) => logger('fatal', payload);\n\n  /**\n   * Logs a payload by error log level.\n   * \n   * @param payload the payload to be logged.\n   */\n  logger.error = (payload: StorageLoggerPayload) => logger('error', payload);\n\n  /**\n   * Logs a payload by warn log level.\n   * \n   * @param payload the payload to be logged.\n   */\n  logger.warn = (payload: StorageLoggerPayload) => logger('warn', payload);\n\n  /**\n   * Logs a payload by info log level.\n   * \n   * @param payload the payload to be logged.\n   */\n  logger.info = (payload: StorageLoggerPayload) => logger('info', payload);\n\n  /**\n   * Logs a payload by debug log level.\n   * \n   * @param payload the payload to be logged.\n   */\n  logger.debug = (payload: StorageLoggerPayload) => logger('debug', payload);\n\n  /**\n   * Creates a child logger instance.\n   * \n   * @example\n   * import defLogger from './path/to/logger'\n   * const logger = defLogger.child('your.namespace');\n   * \n   * @param ns the namspace of the child to create.\n   */\n  logger.child = (ns: string) => {\n    const nextParent = /global$/.test(activeNamespace) ? 'logger' : activeNamespace;\n    return createStorageLogger<K>({ ...options, parent: nextParent, namespace: ns }, namespaces);\n  };\n\n  /**\n   * Returns rows for the active namespace.\n   * \n   * @param limit value used to limit returned rows.\n   */\n  logger.rows = (limit = 0) => {\n    let rows = getKey(activeNamespace).reverse();\n    if (limit)\n      rows = rows.slice(0, limit);\n    return rows;\n  };\n\n  /**\n   * Gets the size of the namespace by row count.\n   */\n  logger.size = () => rowsCount(activeNamespace);\n\n  /**\n   * Clears the current namespace.\n   */\n  logger.clear = () => {\n    removeKey(activeNamespace);\n  };\n\n  /**\n   * Clears all namespaces.\n   */\n  logger.clearAll = () => namespaces.forEach(ns => removeKey(ns));\n\n  /**\n   * Purges lines from the logger.\n   * \n   * @param lines the number of lines to purge.\n   */\n  logger.purge = (lines = 1) => {\n    deleteRows(activeNamespace, lines);\n  };\n\n  return logger;\n\n}\n\n/**\n * Default logger instance.\n */\nconst defaultLogger = createStorageLogger({ parent: 'logger', namespace: 'global' });\n\nexport default defaultLogger;"],"names":["getTimestamp","date","Date","now","toISOString","ENV_LOG_LEVEL","process","env","LOG_LEVELS","STYLES","inherit","dim","log","fatal","error","warn","info","debug","DEFAULTS","type","maxLines","key","keyValue","userKey","level","consoleOutput","styles","defaultLogger","createStorageLogger","options","namespaces","_queueId","store","localStorage","sessionStorage","_a","parent","namespace","initLevel","activeNamespace","ns","split","join","formatNamespace","_queue","startQueue","setInterval","length","payload","rows","getKey","tsKey","shift","trimNs","replace","truncMessage","message","slice","groupLabel","_tokens","_styles","api","tokens","add","unstyled","label","toString","style","push","formatter","console","groupCollapsed","groupEnd","setKey","writePayload","clearInterval","obj","getItem","JSON","parse","data","Array","isArray","str","stringify","setItem","removeKey","removeItem","deleteRows","count","sort","a","b","timestamp","splice","rowsCount","logger","indexOf","isActiveLevel","Error","err","result","Object","getOwnPropertyNames","reduce","c","name","serializeError","checkSize","_payload","user","item","getUser","includes","child","nextParent","test","limit","reverse","size","clear","clearAll","forEach","purge","lines"],"mappings":";;;;;;;;;;;;;;;;;;;iYAuDgBA,EAAaC,GAC3B,oBAD2BA,EAAOC,KAAKC,OAChC,IAAKD,KAAKD,GAAOG,kBCtDbC,EAAmC,oBAAZC,QAA0BA,QAAQC,IAAyB,oBAAI,QAEtFC,EAAoB,CAAC,MAAO,QAAS,QAAS,OAAQ,OAAQ,SAE9DC,EAAS,CACpBC,QAAS,iBACTC,IAAK,cACLC,IAAK,wBACLC,MAAO,2CACPC,MAAO,mBACPC,KAAM,cACNC,KAAM,qBACNC,MAAO,kBAGIC,EAAW,CACtBC,KAAM,QACNC,SAAU,GACVC,IAAK,OACLC,SAAU,WAAM,OAAApB,KAAKC,OACrBoB,QAAS,OACTC,MAAOnB,EACPoB,cAAe,cACfC,YAAajB,QC2UTkB,EAzVN,SAASC,EAAoGC,EAAmCC,gBAAAA,MAS9I,IAOIC,EAPEC,EAAyB,WAL/BH,SACKX,GACAW,IAGiBV,KAAmBc,aAAeC,eAElDC,EAAmGN,EAAjGO,WAAQC,cAAWjB,aAAUC,QAAKC,aAAUC,YAAgBe,UAAWb,kBAAeC,WAExFa,WFyCwBC,EAAYJ,GAE1C,cADqBA,EAAOK,MAAM,OAAMD,IACxBE,KAAK,KE3CGC,CAAgBN,EAAWD,GAE/CQ,EAAqC,GAkBzC,SAASC,IACPd,EAAWe,aAAY,WAChBF,EAAOG,OAqHhB,SAAsBP,EAAYQ,SAC1BC,SAAWC,EAAOV,KAAKQ,IAC7B,GAX0B,WAAlBvB,GAA0D,eAA5BnB,QAAQC,IAAc,SAWxC,CAClB,IAAM4C,YAAQnD,EAAagD,EAAQ3B,IAAMoB,MAAM,KAAKW,8BAASX,MAAM,KAAKC,KAAK,KACvEW,EAASb,EAAGc,QAAQ,YAAa,IACjCC,EAAeP,EAAQQ,QAAQC,MAAM,EAAG,IACxCC,WFpKchC,GAExB,IAAMiC,EAAU,GACVC,EAAU,GAEVC,EAAM,CACVC,OAAQH,EACRjC,OAAQkC,EACRG,MACAC,SAqBF,SAAkBC,GAChB,OAAOF,EAAI,UAAWE,IArBtBC,SA2BF,WACE,UAAQP,EAAQjB,KAAK,MAASkB,KAnBhC,SAASG,EAAII,EAAcF,GAGzB,OAFAN,EAAQS,KAAK,KAAOH,GACpBL,EAAQQ,KAAK1C,EAAOyC,IACbN,EAmBT,OAAOA,EE2HgBQ,CAAU3C,GAC1BqC,IAAIf,EAAQxB,MAAgB2B,GAC5Ba,SAASX,GACTW,SAAS,KACTD,IAAI,MAAOR,GACXW,WACHI,QAAQC,qBAARD,QAA0BZ,GAC1BY,QAAQ1D,IAAIoC,GACZsB,QAAQE,WAEVC,EAAOjC,EAAIS,GAnITyB,CAAanC,EAAiBK,EAAOQ,SAZlCrB,IACL4C,cAAc5C,GACda,EAAS,MAWN,KAQL,SAASM,EAAOV,GACd,IAAMoC,EAAM5C,EAAM6C,QAAQrC,GAC1B,OAAOoC,GAAOA,EAAI7B,OAAS+B,KAAKC,MAAMH,GAAO,GAuB/C,SAASH,EAAOjC,EAAYwC,GAC1B,GAAKA,EAAL,CACKC,MAAMC,QAAQF,KACjBA,EAAO,CAACA,IACV,IAAMG,EAAML,KAAKM,UAAUJ,GAC3BhD,EAAMqD,QAAQ7C,EAAI2C,IAGpB,SAASG,EAAU9C,GACjBR,EAAMuD,WAAW/C,GASnB,SAASgD,EAAWhD,EAAYiD,gBAAAA,KAC9B,IAAMxC,EAAOC,EAAOV,GACpBS,EAAKyC,MAAK,SAACC,EAAGC,GACZ,OAAID,EAAEE,UAAYD,EAAEC,UACX,EACAF,EAAEE,UAAYD,EAAEC,WACf,EAED,KACRC,OAAO,EAAGL,GACbhB,EAAOjC,EAAIS,GAQb,SAAS8C,EAAUvD,GACjB,OAAOU,EAAOV,GAAIO,OA8EpB,SAASiD,EAAOxE,EAAwCwB,GAGtD,QAAqB,IAAVxB,EACT,OAAOwE,EAST,GAPKhD,IACHA,EAAUxB,EACVA,EAAQ,IAGVA,EAAQA,GAAS,OAhEnB,SAAuBA,GAGrB,OAFiBhB,EAAWyF,QAAQzE,IAChBhB,EAAWyF,QAAQD,EAAOxE,OAgEzC0E,CAAcF,EAAOxE,OACxB,OAAOwE,EAEc,iBAAZhD,EACTA,EAAU,CAAEQ,QAASR,GAEdA,aAAmBmD,QAC1BnD,WF9I0CoD,GAC9C,KAAMA,aAAeD,OACnB,OAAOC,EACT,IAAMC,EAASC,OAAOC,oBAAoBH,GAAKI,QAAO,SAACb,EAAGc,GAExD,OADAd,EAAEc,GAAgBL,EAAIK,GACfd,IACN,IAGH,OAFIS,EAAIM,OAASL,EAAOK,OACtBL,EAAOK,KAAON,EAAIM,MACbL,EEqIOM,CAAe3D,IA1F7B,SAAmBR,GACjB,GAAKpB,EAAL,CACA,IAAMqE,EAAQM,EAAUvD,GACpBiD,IAAUrE,EACZoE,EAAWhD,GAEJiD,EAAQrE,GAEfoE,EAAWhD,EADCiD,EAAQrE,IAqFtBwF,CAAUrE,GAEV,IAAMsE,EAAW7D,EAejB,OAdA6D,EAASxF,GAAYC,IACrBuF,EAASxE,UAAYE,EACrBsE,EAAShB,UAAY7F,IACrB6G,EAASrD,QAAUqD,EAASrD,SAAW,GAEnCjC,IACFsF,EAASC,KAhKb,SAAiBzF,GACf,IAAMyF,EAAO7E,aAAa4C,QAAQxD,GAC5B0F,EAAO/E,EAAM6C,QAAQxD,GAC3B,OAAKyF,GAASC,EAEPjC,KAAKC,MAAMgC,GADT,KA4JSC,CAAQzF,IAG1BqB,EAAOwB,KAAKyC,GAEP9E,GACHc,IAEKmD,EAiHT,OAhUKlE,EAAWmF,SAAS1E,IACvBT,EAAWsC,KAAK7B,GAqNlByD,EAAOxE,MAAQc,EAKf0D,EAAO3D,UAAYE,EAKnByD,EAAOlE,WAAaA,EAOpBkE,EAAOpF,IAAM,SAACoC,GAAkC,OAAAgD,EAAO,MAAOhD,IAO9DgD,EAAOnF,MAAQ,SAACmC,GAAkC,OAAAgD,EAAO,QAAShD,IAOlEgD,EAAOlF,MAAQ,SAACkC,GAAkC,OAAAgD,EAAO,QAAShD,IAOlEgD,EAAOjF,KAAO,SAACiC,GAAkC,OAAAgD,EAAO,OAAQhD,IAOhEgD,EAAOhF,KAAO,SAACgC,GAAkC,OAAAgD,EAAO,OAAQhD,IAOhEgD,EAAO/E,MAAQ,SAAC+B,GAAkC,OAAAgD,EAAO,QAAShD,IAWlEgD,EAAOkB,MAAQ,SAAC1E,GACd,IAAM2E,EAAa,UAAUC,KAAK7E,GAAmB,SAAWA,EAChE,OAAOX,SAA4BC,IAASO,OAAQ+E,EAAY9E,UAAWG,IAAMV,IAQnFkE,EAAO/C,KAAO,SAACoE,gBAAAA,KACb,IAAIpE,EAAOC,EAAOX,GAAiB+E,UAGnC,OAFID,IACFpE,EAAOA,EAAKQ,MAAM,EAAG4D,IAChBpE,GAMT+C,EAAOuB,KAAO,WAAM,OAAAxB,EAAUxD,IAK9ByD,EAAOwB,MAAQ,WACblC,EAAU/C,IAMZyD,EAAOyB,SAAW,WAAM,OAAA3F,EAAW4F,SAAQ,SAAAlF,GAAM,OAAA8C,EAAU9C,OAO3DwD,EAAO2B,MAAQ,SAACC,gBAAAA,KACdpC,EAAWjD,EAAiBqF,IAGvB5B,EAOapE,CAAoB,CAAEQ,OAAQ,SAAUC,UAAW"}